{"version":3,"sources":["../src/leg_finder.ts"],"names":["each","isEmpty","flatMap","map","orderBy","pick","sortedIndexBy","debugMod","debug","closestDeltas","strikes","deltas","sorted","contractList","x","Math","abs","delta","length","closest","targetDelta","index","greaterDistance","Infinity","lesserDistance","best","target","contract","contracts","filter","Boolean","closestAfterDte","dates","dteTarget","closestDte","dteNum","Number","parseInt","requireMonthly","dte","expiration","difference","strikeMap","key","expirationDate","dteStr","split","isMonthly","desc","description","endsWith","d","analyzeSide","config","allExpirations","expirations","result","filterLiquidity","data","spreadPercent","maxSpreadPercent","totalVolume","minVolume","openInterest","minOpenInterest","analyzeLiquidity","chain","calls","callExpDateMap","puts","putExpDateMap","allData","concat","results","targetDte","bid","ask","symbol"],"mappings":"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","sourcesContent":["import each from 'lodash/each';\nimport isEmpty from 'lodash/isEmpty';\nimport flatMap from 'lodash/flatMap';\nimport map from 'lodash/map';\nimport orderBy from 'lodash/orderBy';\nimport pick from 'lodash/pick';\nimport sortedIndexBy from 'lodash/sortedIndexBy';\nimport { Dictionary } from 'lodash';\nimport debugMod from 'debug';\nimport { ContractInfo } from 'tda-api';\n\nconst debug = debugMod('option_finder');\n\nexport type StrikeMap = Dictionary<ContractInfo[]>;\nexport type ExpirationDateMap = Dictionary<StrikeMap>;\n\nexport function closestDeltas(strikes: StrikeMap, deltas: number[]) {\n  let sorted = orderBy(\n    map(strikes, (contractList) => contractList[0]),\n    (x) => Math.abs(x.delta),\n    'asc'\n  );\n\n  if (!sorted.length) {\n    return null;\n  }\n\n  let closest = map(deltas, (targetDelta) => {\n    if (targetDelta > 1) {\n      // Deal with 0-1 delta range.\n      targetDelta /= 100;\n    }\n    let index = sortedIndexBy<Partial<ContractInfo>>(\n      sorted,\n      { delta: targetDelta },\n      (x) => Math.abs(x.delta)\n    );\n    let greaterDistance =\n      index < sorted.length\n        ? Math.abs(sorted[index].delta) - targetDelta\n        : Infinity;\n    let lesserDistance =\n      index > 0 ? targetDelta - Math.abs(sorted[index - 1].delta) : Infinity;\n    let best =\n      greaterDistance < lesserDistance ? sorted[index] : sorted[index - 1];\n\n    return {\n      target: targetDelta,\n      contract: best,\n      contracts: [sorted[index - 1], sorted[index]].filter(Boolean),\n    };\n  });\n\n  return closest;\n}\n\ninterface ClosestDte {\n  target: number;\n  dte: number;\n  expiration: string;\n  difference: number;\n  strikes: StrikeMap;\n}\n\nexport function closestAfterDte(\n  dates: ExpirationDateMap,\n  dteTarget: string[]\n): ClosestDte[] {\n  let closestDte = map(dteTarget, (target) => {\n    let dteNum = Number.parseInt(target, 10);\n    let requireMonthly = target[target.length - 1] === 'M';\n    return {\n      target: dteNum,\n      dte: null,\n      expiration: null,\n      difference: Infinity,\n      strikes: null,\n      requireMonthly,\n    };\n  });\n\n  debug(closestDte);\n\n  each(dates, (strikeMap, key) => {\n    let [expirationDate, dteStr] = key.split(':');\n    let dte = +dteStr;\n    let isMonthly = false;\n    each(strikeMap, (contract) => {\n      let desc = contract[0].description || '';\n      isMonthly = !desc.endsWith('(Weekly)');\n      return false;\n    });\n\n    each(closestDte, (d) => {\n      if (d.requireMonthly && !isMonthly) {\n        return;\n      }\n\n      let difference = dte - d.target;\n\n      // If the current expiration >= the target number and is smaller than what we had before, then use it.\n      if (difference >= 0 && difference < d.difference) {\n        d.strikes = strikeMap;\n        d.difference = difference;\n        d.dte = dte;\n        d.expiration = expirationDate;\n      }\n    });\n  });\n\n  return closestDte;\n}\n\nexport interface AnalyzeSideOptions {\n  dte: string[];\n  delta: number[];\n}\n\nexport function analyzeSide(\n  config: AnalyzeSideOptions,\n  allExpirations: ExpirationDateMap\n) {\n  if (isEmpty(allExpirations)) {\n    return [];\n  }\n\n  let expirations = closestAfterDte(allExpirations, config.dte);\n  let result = map(expirations, (expiration) => {\n    let deltas = closestDeltas(expiration.strikes, config.delta);\n    return {\n      deltas,\n      ...expiration,\n    };\n  });\n\n  return result;\n}\n\nexport interface FilterLiquidityArguments {\n  maxSpreadPercent?: number;\n  minVolume?: number;\n  minOpenInterest?: number;\n}\n\nexport interface LiquidityInfo {\n  spreadPercent?: number;\n  totalVolume?: number;\n  openInterest?: number;\n}\n\nexport function filterLiquidity(\n  config: FilterLiquidityArguments,\n  data: LiquidityInfo\n) {\n  if (data.spreadPercent > (config.maxSpreadPercent || Infinity)) {\n    return false;\n  }\n\n  if (data.totalVolume < (config.minVolume || 0)) {\n    return false;\n  }\n\n  if (data.openInterest < (config.minOpenInterest || 0)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport interface AnalyzeLiquidityOptions {\n  symbol: string;\n  callExpDateMap: ExpirationDateMap;\n  putExpDateMap: ExpirationDateMap;\n}\n\nexport function analyzeLiquidity(\n  config: AnalyzeSideOptions & FilterLiquidityArguments,\n  chain: AnalyzeLiquidityOptions\n) {\n  // debug(\"Analyzing\", chain, typeof chain, \"array\", isArray(chain));\n  let calls = analyzeSide(config, chain.callExpDateMap);\n  let puts = analyzeSide(config, chain.putExpDateMap);\n\n  let allData = calls.concat(puts);\n  let results = flatMap(allData, (expiration) => {\n    return expiration.deltas\n      .map((delta) => {\n        let contract = delta.contract;\n        return {\n          expiration: expiration.expiration,\n          targetDte: expiration.target,\n          targetDelta: delta.target,\n          spreadPercent: contract.bid\n            ? (contract.ask / contract.bid - 1) * 100\n            : 1000,\n          ...pick(contract, [\n            'symbol',\n            'delta',\n            'putCall',\n            'strikePrice',\n            'daysToExpiration',\n            'bid',\n            'ask',\n            'totalVolume',\n            'openInterest',\n          ]),\n        };\n      })\n      .filter((data) => filterLiquidity(config, data));\n  });\n\n  debug('Results', chain.symbol, results);\n\n  return { symbol: chain.symbol, results };\n}\n"],"file":"leg_finder.js"}