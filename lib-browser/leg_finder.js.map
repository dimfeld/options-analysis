{"version":3,"sources":["../src/leg_finder.ts"],"names":["each","map","pick","flatMap","isEmpty","orderBy","sortedIndexBy","debugMod","debug","closestDeltas","strikes","deltas","sorted","contractList","x","Math","abs","delta","length","closest","targetDelta","index","greaterDistance","Infinity","lesserDistance","best","target","contract","closestAfterDte","dates","dteTarget","closestDte","dteNum","Number","parseInt","requireMonthly","dte","expiration","difference","strikeMap","key","expirationDate","dteStr","split","isMonthly","desc","description","endsWith","d","analyzeSide","config","allExpirations","expirations","result","filterLiquidity","data","spreadPercent","maxSpreadPercent","totalVolume","minVolume","openInterest","minOpenInterest","analyzeLiquidity","chain","calls","callExpDateMap","puts","putExpDateMap","allData","concat","results","targetDte","bid","ask","filter","symbol"],"mappings":"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","sourcesContent":["import each from 'lodash/each';\nimport map from 'lodash/map';\nimport pick from 'lodash/pick';\nimport flatMap from 'lodash/flatMap';\nimport isEmpty from 'lodash/isEmpty';\nimport orderBy from 'lodash/orderBy';\nimport sortedIndexBy from 'lodash/sortedIndexBy';\nimport { Dictionary } from 'lodash';\nimport debugMod from 'debug';\nimport { ContractInfo } from 'tda-api';\n\nconst debug = debugMod('option_finder');\n\nexport type StrikeMap = Dictionary<ContractInfo[]>;\nexport type ExpirationDateMap = Dictionary<StrikeMap>;\n\nexport function closestDeltas(strikes: StrikeMap, deltas: number[]) {\n  let sorted = orderBy(\n    map(strikes, (contractList) => contractList[0]),\n    (x) => Math.abs(x.delta),\n    'asc'\n  );\n\n  if (!sorted.length) {\n    return null;\n  }\n\n  let closest = map(deltas, (targetDelta) => {\n    if (targetDelta > 1) {\n      // Deal with 0-1 delta range.\n      targetDelta /= 100;\n    }\n    let index = sortedIndexBy<Partial<ContractInfo>>(\n      sorted,\n      { delta: targetDelta },\n      (x) => Math.abs(x.delta)\n    );\n    let greaterDistance =\n      index < sorted.length\n        ? Math.abs(sorted[index].delta - targetDelta)\n        : Infinity;\n    let lesserDistance =\n      index > 0 ? Math.abs(sorted[index - 1].delta - targetDelta) : Infinity;\n    let best =\n      greaterDistance < lesserDistance ? sorted[index] : sorted[index - 1];\n    return { target: targetDelta, contract: best };\n  });\n\n  return closest;\n}\n\ninterface ClosestDte {\n  target: number;\n  dte: number;\n  expiration: string;\n  difference: number;\n  strikes: StrikeMap;\n}\n\nexport function closestAfterDte(\n  dates: ExpirationDateMap,\n  dteTarget: string[]\n): ClosestDte[] {\n  let closestDte = map(dteTarget, (target) => {\n    let dteNum = Number.parseInt(target, 10);\n    let requireMonthly = target[target.length - 1] === 'M';\n    return {\n      target: dteNum,\n      dte: null,\n      expiration: null,\n      difference: Infinity,\n      strikes: null,\n      requireMonthly,\n    };\n  });\n\n  debug(closestDte);\n\n  each(dates, (strikeMap, key) => {\n    let [expirationDate, dteStr] = key.split(':');\n    let dte = +dteStr;\n    let isMonthly = false;\n    each(strikeMap, (contract) => {\n      let desc = contract[0].description || '';\n      isMonthly = !desc.endsWith('(Weekly)');\n      return false;\n    });\n\n    each(closestDte, (d) => {\n      if (d.requireMonthly && !isMonthly) {\n        return;\n      }\n\n      let difference = dte - d.target;\n\n      // If the current expiration >= the target number and is smaller than what we had before, then use it.\n      if (difference >= 0 && difference < d.difference) {\n        d.strikes = strikeMap;\n        d.difference = difference;\n        d.dte = dte;\n        d.expiration = expirationDate;\n      }\n    });\n  });\n\n  return closestDte;\n}\n\nexport interface AnalyzeSideOptions {\n  dte: string[];\n  delta: number[];\n}\n\nexport function analyzeSide(\n  config: AnalyzeSideOptions,\n  allExpirations: ExpirationDateMap\n) {\n  if (isEmpty(allExpirations)) {\n    return [];\n  }\n\n  let expirations = closestAfterDte(allExpirations, config.dte);\n  let result = map(expirations, (expiration) => {\n    let deltas = closestDeltas(expiration.strikes, config.delta);\n    return {\n      deltas,\n      ...expiration,\n    };\n  });\n\n  return result;\n}\n\nexport interface FilterLiquidityArguments {\n  maxSpreadPercent?: number;\n  minVolume?: number;\n  minOpenInterest?: number;\n}\n\nexport interface LiquidityInfo {\n  spreadPercent?: number;\n  totalVolume?: number;\n  openInterest?: number;\n}\n\nexport function filterLiquidity(\n  config: FilterLiquidityArguments,\n  data: LiquidityInfo\n) {\n  if (data.spreadPercent > (config.maxSpreadPercent || Infinity)) {\n    return false;\n  }\n\n  if (data.totalVolume < (config.minVolume || 0)) {\n    return false;\n  }\n\n  if (data.openInterest < (config.minOpenInterest || 0)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport interface AnalyzeLiquidityOptions {\n  symbol: string;\n  callExpDateMap: ExpirationDateMap;\n  putExpDateMap: ExpirationDateMap;\n}\n\nexport function analyzeLiquidity(\n  config: AnalyzeSideOptions & FilterLiquidityArguments,\n  chain: AnalyzeLiquidityOptions\n) {\n  // debug(\"Analyzing\", chain, typeof chain, \"array\", _.isArray(chain));\n  let calls = analyzeSide(config, chain.callExpDateMap);\n  let puts = analyzeSide(config, chain.putExpDateMap);\n\n  let allData = calls.concat(puts);\n  let results = flatMap(allData, (expiration) => {\n    return map(expiration.deltas, (delta) => {\n      let contract = delta.contract;\n      return {\n        expiration: expiration.expiration,\n        targetDte: expiration.target,\n        targetDelta: delta.target,\n        spreadPercent: contract.bid\n          ? (contract.ask / contract.bid - 1) * 100\n          : 1000,\n        ...pick(contract, [\n          'symbol',\n          'delta',\n          'putCall',\n          'strikePrice',\n          'daysToExpiration',\n          'bid',\n          'ask',\n          'totalVolume',\n          'openInterest',\n        ]),\n      };\n    }).filter((data) => filterLiquidity(config, data));\n  });\n\n  debug('Results', chain.symbol, results);\n\n  return { symbol: chain.symbol, results };\n}\n"],"file":"leg_finder.js"}