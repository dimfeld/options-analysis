{"version":3,"sources":["../src/position_info.ts"],"names":["_","positionInfo","position","fetchQuote","legData","trades","forEach","trade","legs","leg","thisLong","size","data","symbol","openingIsLong","openLegs","maxLegs","basis","realized","multiplier","length","value","price","Math","abs","underlyingPrice","currentLegValues","map","legPrice","NaN","openValue","sum","totalRealized","totalBasis","openBasis","unrealized","openPlPct","totalPlPct"],"mappings":"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","sourcesContent":["import * as _ from 'lodash';\nimport { Dictionary } from 'lodash';\nimport { Position, Trade } from './types';\n\nexport default function positionInfo<T extends Position<TR>, TR extends Trade>(\n  position: T,\n  fetchQuote: (symbol: string) => number | null\n) {\n  interface LegData {\n    openingIsLong: boolean;\n    basis: number;\n    openLegs: number;\n    maxLegs: number;\n    realized: number;\n  }\n\n  let legData: Dictionary<LegData> = {};\n\n  position.trades.forEach((trade) => {\n    trade.legs.forEach((leg) => {\n      let thisLong = leg.size > 0;\n      let data = legData[leg.symbol];\n      if (!data) {\n        data = legData[leg.symbol] = {\n          openingIsLong: thisLong,\n          openLegs: 0,\n          maxLegs: 0,\n          basis: 0,\n          realized: 0,\n        };\n      }\n\n      let multiplier = leg.symbol.length > 6 ? 100 : 1;\n      let value = leg.size * leg.price * multiplier;\n\n      // If this leg was opened in the same direction as the\n      // original leg (or it's the first) then add it to the basis.\n      if (thisLong === data.openingIsLong) {\n        data.basis += value;\n        data.maxLegs += leg.size;\n      } else {\n        let realized = data.basis * Math.abs(leg.size / data.maxLegs) + value;\n        data.realized += realized;\n      }\n\n      data.openLegs += leg.size;\n    });\n  });\n\n  let underlyingPrice = fetchQuote(position.symbol);\n  let currentLegValues = position.legs.map((leg) => {\n    let legPrice = fetchQuote(leg.symbol);\n    if (!legPrice) {\n      return NaN;\n    }\n\n    let multiplier = leg.symbol.length > 6 ? 100 : 1;\n    return leg.size * legPrice * multiplier;\n  });\n\n  let openValue = _.sum(currentLegValues);\n\n  let totalRealized = _.sum(_.map(legData, (leg) => leg.realized));\n  let totalBasis = _.sum(_.map(legData, (leg) => leg.basis));\n  let openBasis = _.sum(\n    _.map(legData, (leg) => leg.basis * (leg.openLegs / leg.maxLegs))\n  );\n\n  let unrealized = openValue - openBasis;\n  let openPlPct = unrealized / openBasis;\n  let totalPlPct = (unrealized + totalRealized) / totalBasis;\n\n  return {\n    underlyingPrice,\n\n    totalPlPct,\n    totalRealized,\n    totalBasis,\n\n    openPlPct,\n    unrealized,\n    openBasis,\n  };\n}\n"],"file":"position_info.js"}