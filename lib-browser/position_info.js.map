{"version":3,"sources":["../src/position_info.ts"],"names":["sum","map","positionInfo","position","fetchQuote","openTotalBasis","maxTotalBasis","legData","trades","forEach","trade","legs","leg","thisLong","size","data","symbol","openingIsLong","openLegs","maxLegs","totalBasis","openBasis","realized","multiplier","length","value","price","theseLegsBasis","Math","abs","underlyingPrice","currentLegValues","legPrice","NaN","openValue","totalRealized","unrealized","openPlPct","totalPlPct","netLiquidity"],"mappings":"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","sourcesContent":["import { Dictionary } from 'lodash';\nimport sum from 'lodash/sum';\nimport map from 'lodash/map';\nimport { Position, Trade, PositionLegInfo } from './types';\n\nexport default function positionInfo<T extends Position<TR>, TR extends Trade>(\n  position: T,\n  fetchQuote: (symbol: string) => number | null\n) {\n  let openTotalBasis = 0;\n  let maxTotalBasis = 0;\n\n  let legData: Dictionary<PositionLegInfo> = {};\n\n  position.trades.forEach((trade) => {\n    trade.legs.forEach((leg) => {\n      let thisLong = leg.size > 0;\n      let data = legData[leg.symbol];\n      if (!data) {\n        data = legData[leg.symbol] = {\n          openingIsLong: thisLong,\n          openLegs: 0,\n          maxLegs: 0,\n          totalBasis: 0,\n          openBasis: 0,\n          realized: 0,\n          multiplier: leg.symbol.length > 6 ? 100 : 1,\n        };\n      }\n\n      let value = leg.size * leg.price * data.multiplier;\n\n      // If this leg was opened in the same direction as the\n      // original leg (or it's the first) then add it to the basis.\n      if (thisLong === data.openingIsLong) {\n        data.maxLegs += leg.size;\n        data.openBasis += value;\n        openTotalBasis += value;\n      } else {\n        let theseLegsBasis =\n          data.openBasis * Math.abs(leg.size / data.openLegs);\n        data.openBasis -= theseLegsBasis;\n        openTotalBasis -= theseLegsBasis;\n\n        let realized = -1 * (value + theseLegsBasis);\n        data.realized += realized;\n      }\n\n      if (Math.abs(data.openBasis) > Math.abs(data.totalBasis)) {\n        data.totalBasis = data.openBasis;\n      }\n\n      data.openLegs += leg.size;\n    });\n\n    if (Math.abs(openTotalBasis) > Math.abs(maxTotalBasis)) {\n      maxTotalBasis = openTotalBasis;\n    }\n  });\n\n  let underlyingPrice = fetchQuote(position.symbol);\n  let currentLegValues = position.legs.map((leg) => {\n    let legPrice = fetchQuote(leg.symbol);\n    if (!legPrice) {\n      return NaN;\n    }\n\n    let multiplier = leg.symbol.length > 6 ? 100 : 1;\n    return leg.size * legPrice * multiplier;\n  });\n\n  let openValue = sum(currentLegValues);\n\n  let totalRealized = sum(map(legData, (leg) => leg.realized));\n\n  let unrealized = openValue - openTotalBasis;\n  let openPlPct =\n    openTotalBasis === 0 ? 0 : (100 * unrealized) / Math.abs(openTotalBasis);\n  let totalPlPct =\n    (100 * (unrealized + totalRealized)) / Math.abs(maxTotalBasis);\n\n  return {\n    underlyingPrice,\n\n    totalPlPct,\n    totalRealized,\n    totalBasis: maxTotalBasis,\n\n    openPlPct,\n    unrealized,\n    openBasis: openTotalBasis,\n\n    netLiquidity: openValue,\n\n    legData,\n  };\n}\n"],"file":"position_info.js"}