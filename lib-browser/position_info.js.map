{"version":3,"sources":["../src/position_info.ts"],"names":["sum","map","positionInfo","position","fetchQuote","openTotalBasis","maxTotalBasis","legData","trades","forEach","trade","legs","leg","thisLong","size","data","symbol","openingIsLong","openLegs","openBasis","realized","multiplier","length","value","price","theseLegsBasis","Math","abs","underlyingPrice","currentLegValues","legPrice","NaN","openValue","totalRealized","unrealized","openPlPct","totalPlPct","totalBasis","netLiquidity"],"mappings":"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","sourcesContent":["import { Dictionary } from 'lodash';\nimport sum from 'lodash/sum';\nimport map from 'lodash/map';\nimport { Position, Trade } from './types';\n\nexport default function positionInfo<T extends Position<TR>, TR extends Trade>(\n  position: T,\n  fetchQuote: (symbol: string) => number | null\n) {\n  interface LegData {\n    openingIsLong: boolean;\n    openBasis: number;\n    openLegs: number;\n    realized: number;\n  }\n\n  let openTotalBasis = 0;\n  let maxTotalBasis = 0;\n\n  let legData: Dictionary<LegData> = {};\n\n  position.trades.forEach((trade) => {\n    trade.legs.forEach((leg) => {\n      let thisLong = leg.size > 0;\n      let data = legData[leg.symbol];\n      if (!data) {\n        data = legData[leg.symbol] = {\n          openingIsLong: thisLong,\n          openLegs: 0,\n          openBasis: 0,\n          realized: 0,\n        };\n      }\n\n      let multiplier = leg.symbol.length > 6 ? 100 : 1;\n      let value = leg.size * leg.price * multiplier;\n\n      // If this leg was opened in the same direction as the\n      // original leg (or it's the first) then add it to the basis.\n      if (thisLong === data.openingIsLong) {\n        data.openBasis += value;\n        openTotalBasis += value;\n      } else {\n        let theseLegsBasis =\n          data.openBasis * Math.abs(leg.size / data.openLegs);\n        data.openBasis -= theseLegsBasis;\n        openTotalBasis -= theseLegsBasis;\n\n        let realized = -1 * (value + theseLegsBasis);\n        data.realized += realized;\n      }\n\n      data.openLegs += leg.size;\n    });\n\n    if (Math.abs(openTotalBasis) > Math.abs(maxTotalBasis)) {\n      maxTotalBasis = openTotalBasis;\n    }\n  });\n\n  let underlyingPrice = fetchQuote(position.symbol);\n  let currentLegValues = position.legs.map((leg) => {\n    let legPrice = fetchQuote(leg.symbol);\n    if (!legPrice) {\n      return NaN;\n    }\n\n    let multiplier = leg.symbol.length > 6 ? 100 : 1;\n    return leg.size * legPrice * multiplier;\n  });\n\n  let openValue = sum(currentLegValues);\n\n  let totalRealized = sum(map(legData, (leg) => leg.realized));\n\n  let unrealized = openValue - openTotalBasis;\n  let openPlPct =\n    openTotalBasis === 0 ? 0 : (100 * unrealized) / Math.abs(openTotalBasis);\n  let totalPlPct =\n    (100 * (unrealized + totalRealized)) / Math.abs(maxTotalBasis);\n\n  return {\n    underlyingPrice,\n\n    totalPlPct,\n    totalRealized,\n    totalBasis: maxTotalBasis,\n\n    openPlPct,\n    unrealized,\n    openBasis: openTotalBasis,\n\n    netLiquidity: openValue,\n  };\n}\n"],"file":"position_info.js"}