{"version":3,"sources":["../src/leg_finder.ts"],"names":["debug","closestDeltas","strikes","deltas","sorted","_","chain","map","contractList","orderBy","x","Math","abs","delta","value","length","closest","targetDelta","index","sortedIndexBy","greaterDistance","Infinity","lesserDistance","best","target","contract","closestAfterDte","dates","dteTarget","closestDte","dteNum","Number","parseInt","requireMonthly","dte","expiration","difference","each","strikeMap","key","expirationDate","dteStr","split","isMonthly","desc","description","endsWith","d","analyzeSide","config","allExpirations","isEmpty","expirations","result","filterLiquidity","data","spreadPercent","maxSpreadPercent","totalVolume","minVolume","openInterest","minOpenInterest","analyzeLiquidity","calls","callExpDateMap","puts","putExpDateMap","allData","concat","results","flatMap","targetDte","bid","ask","pick","filter","symbol"],"mappings":"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","sourcesContent":["import _ from 'lodash';\nimport debugMod from 'debug';\nimport { ContractInfo } from 'tda-api';\n\nconst debug = debugMod('option_finder');\n\nexport type StrikeMap = _.Dictionary<ContractInfo[]>;\nexport type ExpirationDateMap = _.Dictionary<StrikeMap>;\n\nexport function closestDeltas(strikes: StrikeMap, deltas: number[]) {\n  let sorted = _.chain(strikes)\n    .map((contractList) => contractList[0])\n    .orderBy((x) => Math.abs(x.delta), 'asc')\n    .value();\n  if (!sorted.length) {\n    return null;\n  }\n\n  let closest = _.map(deltas, (targetDelta) => {\n    if (targetDelta > 1) {\n      // Deal with 0-1 delta range.\n      targetDelta /= 100;\n    }\n    let index = _.sortedIndexBy<Partial<ContractInfo>>(\n      sorted,\n      { delta: targetDelta },\n      (x) => Math.abs(x.delta)\n    );\n    let greaterDistance =\n      index < sorted.length\n        ? Math.abs(sorted[index].delta - targetDelta)\n        : Infinity;\n    let lesserDistance =\n      index > 0 ? Math.abs(sorted[index - 1].delta - targetDelta) : Infinity;\n    let best =\n      greaterDistance < lesserDistance ? sorted[index] : sorted[index - 1];\n    return { target: targetDelta, contract: best };\n  });\n\n  return closest;\n}\n\ninterface ClosestDte {\n  target: number;\n  dte: number;\n  expiration: string;\n  difference: number;\n  strikes: StrikeMap;\n}\n\nexport function closestAfterDte(\n  dates: ExpirationDateMap,\n  dteTarget: string[]\n): ClosestDte[] {\n  let closestDte = _.map(dteTarget, (target) => {\n    let dteNum = Number.parseInt(target, 10);\n    let requireMonthly = target[target.length - 1] === 'M';\n    return {\n      target: dteNum,\n      dte: null,\n      expiration: null,\n      difference: Infinity,\n      strikes: null,\n      requireMonthly,\n    };\n  });\n\n  debug(closestDte);\n\n  _.each(dates, (strikeMap, key) => {\n    let [expirationDate, dteStr] = key.split(':');\n    let dte = +dteStr;\n    let isMonthly = false;\n    _.each(strikeMap, (contract) => {\n      let desc = contract[0].description || '';\n      isMonthly = !desc.endsWith('(Weekly)');\n      return false;\n    });\n\n    _.each(closestDte, (d) => {\n      if (d.requireMonthly && !isMonthly) {\n        return;\n      }\n\n      let difference = dte - d.target;\n\n      // If the current expiration >= the target number and is smaller than what we had before, then use it.\n      if (difference >= 0 && difference < d.difference) {\n        d.strikes = strikeMap;\n        d.difference = difference;\n        d.dte = dte;\n        d.expiration = expirationDate;\n      }\n    });\n  });\n\n  return closestDte;\n}\n\nexport interface AnalyzeSideOptions {\n  dte: string[];\n  delta: number[];\n}\n\nexport function analyzeSide(\n  config: AnalyzeSideOptions,\n  allExpirations: ExpirationDateMap\n) {\n  if (_.isEmpty(allExpirations)) {\n    return [];\n  }\n\n  let expirations = closestAfterDte(allExpirations, config.dte);\n  let result = _.map(expirations, (expiration) => {\n    let deltas = closestDeltas(expiration.strikes, config.delta);\n    return {\n      deltas,\n      ...expiration,\n    };\n  });\n\n  return result;\n}\n\nexport interface FilterLiquidityArguments {\n  maxSpreadPercent?: number;\n  minVolume?: number;\n  minOpenInterest?: number;\n}\n\nexport interface LiquidityInfo {\n  spreadPercent?: number;\n  totalVolume?: number;\n  openInterest?: number;\n}\n\nexport function filterLiquidity(\n  config: FilterLiquidityArguments,\n  data: LiquidityInfo\n) {\n  if (data.spreadPercent > (config.maxSpreadPercent || Infinity)) {\n    return false;\n  }\n\n  if (data.totalVolume < (config.minVolume || 0)) {\n    return false;\n  }\n\n  if (data.openInterest < (config.minOpenInterest || 0)) {\n    return false;\n  }\n\n  return true;\n}\n\nexport interface AnalyzeLiquidityOptions {\n  symbol: string;\n  callExpDateMap: ExpirationDateMap;\n  putExpDateMap: ExpirationDateMap;\n}\n\nexport function analyzeLiquidity(\n  config: AnalyzeSideOptions & FilterLiquidityArguments,\n  chain: AnalyzeLiquidityOptions\n) {\n  // debug(\"Analyzing\", chain, typeof chain, \"array\", _.isArray(chain));\n  let calls = analyzeSide(config, chain.callExpDateMap);\n  let puts = analyzeSide(config, chain.putExpDateMap);\n\n  let allData = calls.concat(puts);\n  let results = _.flatMap(allData, (expiration) => {\n    return _.chain(expiration.deltas)\n      .map((delta) => {\n        let contract = delta.contract;\n        return {\n          expiration: expiration.expiration,\n          targetDte: expiration.target,\n          targetDelta: delta.target,\n          spreadPercent: contract.bid\n            ? (contract.ask / contract.bid - 1) * 100\n            : 1000,\n          ..._.pick(contract, [\n            'symbol',\n            'delta',\n            'putCall',\n            'strikePrice',\n            'daysToExpiration',\n            'bid',\n            'ask',\n            'totalVolume',\n            'openInterest',\n          ]),\n        };\n      })\n      .filter((data) => filterLiquidity(config, data))\n      .value();\n  });\n\n  debug('Results', chain.symbol, results);\n\n  return { symbol: chain.symbol, results };\n}\n"],"file":"leg_finder.js"}